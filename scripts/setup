#!/usr/bin/python3

import curses
import os
import sys
from functools import wraps
from pathlib import Path

import requests
from lxml import html

script_dir = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.join(script_dir, "../modules"))

from metro_support import MetroSetup


def create_file(path: Path, contents, echo=True):
	if not path.parent.exists():
		os.makedirs(path.parent, mode=770, exist_ok=True)
	with open(path, mode='w', encoding="utf-8") as f:
		f.write(contents)
	if echo:
		print(f"Created file {path} with contents '{contents}'")


def sorted_list(func):
	@wraps(func)
	def new_func(*args, **kwargs):
		r = func(*args, **kwargs)
		return sorted(list(r))

	return new_func


class CursesChooser:
	key_pressed = None
	items = None
	screen = None
	max_row = None
	box = None
	value = None
	position = 0
	heading = ""

	def __init__(self, strings: list, keys=None, heading=None):
		self.items = strings
		self.keys = keys
		if heading:
			self.heading = heading

	def display(self, screen):
		self.screen = screen
		curses.noecho()
		curses.cbreak()
		curses.start_color()
		self.screen.keypad(True)
		curses.curs_set(0)
		curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_GREEN)
		curses.init_pair(2, curses.COLOR_CYAN, curses.A_NORMAL)
		self.value = self.get_value()

	def setup(self):
		self.screen.erase()
		self.screen.addstr(0, 0, self.heading, curses.A_BOLD)

	def refresh(self):
		self.screen.refresh()
		self.box.refresh()

	def menu(self):
		lines, cols = self.screen.getmaxyx()
		self.max_row = lines - 4
		if self.max_row <= 0:
			raise ValueError("Not enough terminal lines to display menu.")
		self.box = curses.newwin(lines - 2, max(cols, 64), 2, 1)
		self.box.erase()

		# Limit position to sane values:

		self.position = min(self.position, len(self.items) - 1)
		self.position = max(self.position, 0)

		page = self.position // self.max_row
		start = page * self.max_row
		end = start + self.max_row

		scr_pos = 0

		item_pos = start
		got_to_end = False
		while True:
			if item_pos >= len(self.items):
				got_to_end = True
				break
			elif item_pos >= end:
				break
			elif item_pos == self.position:
				self.box.addstr(scr_pos, 1, f"{item_pos + 1:2}. {self.items[item_pos]}", curses.color_pair(1))
			else:
				self.box.addstr(scr_pos, 1, f"{item_pos + 1:2}. {self.items[item_pos]}", curses.A_NORMAL)
			item_pos += 1
			scr_pos += 1

		if not got_to_end:
			self.box.addstr(scr_pos, 2, u" \u2193 more \u2193", curses.color_pair(2))

	def get_value(self):
		self.setup()
		while True:
			self.menu()
			self.refresh()
			x = self.screen.getch()
			if self.keys is not None and chr(x) in self.keys:
				self.key_pressed = chr(x)
				break
			elif x == curses.KEY_RESIZE:
				self.setup()
			elif x == curses.KEY_DOWN:
				self.position += 1
			elif x == curses.KEY_UP:
				self.position -= 1
			elif x == curses.KEY_RIGHT:
				self.position += self.max_row
			elif x == curses.KEY_LEFT:
				self.position -= self.max_row
			elif x == ord("\n"):
				return self.items[self.position]


def get_http_dirs(url):
	response = requests.get(url)
	tree = html.fromstring(response.content)
	links = tree.xpath("//a/text()")
	return links


class BuildSelector:
	def releases(self) -> list:
		pass

	def arches(self, release) -> list:
		pass

	def subarches(self, release, arch) -> list:
		pass


class LiveBuildSelector:

	@sorted_list
	def releases(self):
		for link in get_http_dirs("https://build.funtoo.org"):
			link = str(link)
			if not link.endswith("/"):
				continue
			if "release" in link:
				yield link.rstrip("/")
			elif link.endswith("next/"):
				yield link.rstrip("/")
			else:
				continue

	@sorted_list
	def arches(self, release):
		for link in get_http_dirs(f"https://build.funtoo.org/{release}"):
			link = str(link)
			if not link.endswith("/"):
				continue
			elif link == "snapshots/":
				continue
			yield link.rstrip("/")

	@sorted_list
	def subarches(self, release, arch):
		for link in get_http_dirs(f"https://build.funtoo.org/{release}/{arch}"):
			link = str(link)
			if not link.endswith("/"):
				continue
			yield link.rstrip("/")


class FileSystemBuildSelector:

	def __init__(self, root):
		self.root = Path(root)

	@sorted_list
	def releases(self):
		if not self.root.exists():
			return
		for dir in self.root.iterdir():
			if not dir.is_dir():
				continue
			elif "release" in dir.name:
				yield dir.name
			elif dir.name == "next":
				yield "next"
			else:
				continue

	@sorted_list
	def arches(self, release):
		rel_dir = self.root.joinpath(release)
		if not rel_dir.exists():
			return
		for dir in rel_dir.iterdir():
			if not dir.is_dir():
				continue
			elif dir.name == "snapshots":
				continue
			yield dir.name

	@sorted_list
	def subarches(self, release, arch):
		sub_dir = self.root.joinpath(release, arch)
		if not sub_dir.exists():
			return
		for dir in sub_dir.iterdir():
			if not dir.is_dir():
				continue
			yield dir.name


def user_select(screen, label, selector):
	releases = selector.releases()
	chooser = CursesChooser(releases, heading=f"{label} / funtoo")
	chooser.display(screen)
	release = chooser.value

	arches = selector.arches(release)
	chooser = CursesChooser(arches, heading=f"{label} / funtoo / {release}")
	chooser.display(screen)
	arch = chooser.value

	subarches = selector.subarches(release, arch)
	chooser = CursesChooser(subarches, heading=f"{label} / funtoo / {release} / {arch}")
	chooser.display(screen)
	subarch = chooser.value

	return release, arch, subarch


def curses_main(screen):
	try:
		selector = LiveBuildSelector()
		return user_select(screen, "www.funtoo.org", selector)
	except ValueError:
		print()


def main():
	try:
		settings = MetroSetup().get_settings()
		if "path/mirror" not in settings:
			raise RuntimeError("path/mirror not defined")
		elif not os.path.exists(settings["path/mirror"]):
			raise RuntimeError(
				f"{settings['path/mirror']} (path/mirror in ~/.metro) does not appear to exist. Please create it.")
		else:
			try:
				test_file = Path(settings['path/mirror']).joinpath(".test_write")
				create_file(test_file, "test", echo=False)
				os.unlink(test_file)
			except PermissionError:
				raise RuntimeError(
					f"Unable to write to {settings['path/mirror']}. Please run as root (preferred) or change permissions on this directory.")
	except (RuntimeError, OSError) as e:
		print(f"Exception: {e}")
		print("""
Please copy metro.conf to ~/.metro and customize path/install to point to the location where metro
is installed, and path/mirror to where you want to store stages.		
""")
		sys.exit(1)
	path_parts = curses.wrapper(curses_main)
	sub_path = Path(settings['path/mirror']).joinpath(*path_parts)
	print(sub_path)
	c_path = sub_path.joinpath(".control")
	create_file(c_path.joinpath("strategy", "build"), "stage3")


if __name__ == "__main__":
	main()
