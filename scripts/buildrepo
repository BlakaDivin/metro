#!/usr/bin/python3

import os
import os.path
import sys
import glob
import datetime
from db import *

cfgfile = os.path.join(os.path.expanduser("~"),".buildbot")
if os.path.exists(cfgfile):
    exec(open(cfgfile, "rb").read())
else:
    print("""
Create a ~/.buildbot file that contains something like this (python syntax):

builds = (
	"funtoo-experimental",
	"funtoo-current",
	"funtoo-current-hardened",
	"funtoo-stable",
)

arches = (
	"x86-32bit",
	"x86-64bit",
	"sparc-64bit",
	"pure64"
)

subarches = ( 
	"atom_32",
	"atom_64",
	"corei7",
	"corei7-pure64",
	"generic_32", 
	"i686", 
	"athlon-xp",
	"pentium4",
	"core2_32",
	"amd64-k8_32",
	"amd64-k8",
	"amd64-k10",
	"core2_64",
	"generic_64",
	"generic_64-pure64",
)

def map_build(build, subarch, full, full_date):
	# arguments refer to last build...
	if full == True:
		buildtype = "freshen"
	else:
		buildtype = "full"
	if subarch in [ "corei7", "corei7-pure64", "generic_64",  "generic_64-pure64" ]:
		buildtype = buildtype + "+openvz"
	return buildtype
""")
    sys.exit(1)

class SubArch(dbobject):
	@classmethod
	def _makeTable(cls,db):
		cls.db = db
		cls.__table__ = Table('subarch', db.metadata,
			Column('id', Integer, primary_key = True),
			Column('date', DateTime, index=True),
			Column('date_str', String, index=True),
			Column('path', String, index=True),
			Column('build', String, index=True),
			Column('arch', String, index=True),
			Column('subarch', String, index=True),
		)

class BuildDir(dbobject):
	@classmethod
	def _makeTable(cls,db):
		cls.db = db
		cls.__table__ = Table('bdir', db.metadata,
			Column('id', Integer, primary_key = True),
			Column('date', DateTime, index=True),
			Column('path', String, index=True),
			Column('build', String, index=True),
			Column('arch', String, index=True),
			Column('subarch', String, index=True),
			Column('date_str', String, index=True),
			Column('complete', Boolean, index=True),
			Column('full', Boolean, index=True)
		)

class Snapshot(dbobject):
	@classmethod
	def _makeTable(cls,db):
		cls.db = db
		cls.__table__ = Table('snapshot', db.metadata,
			Column('id', Integer, primary_key = True),
			Column('path', String, index=True),
			Column('build', String, index=True),
		)

class RepositoryDatabase(Database):
	__database__ = "sqlite:///cleaner.db"
	def __init__(self):
		Database.__init__(self,[BuildDir, Snapshot, SubArch])
		self.associate()
	def associate(self):
		Database.associate(self,self.__database__)

from subprocess import Popen, PIPE

process = Popen(["%s/../metro" % os.path.dirname(os.path.realpath(__file__)), "-k", "path/mirror"], stdout=PIPE, stderr=PIPE)
out = process.stdout.read()
ret = process.wait()
if ret:
	print("Error calling metro for mirror path.")
else:
	initial_path = out.decode("ascii").strip()

initial_path = "/mnt/data/funtoo"

if __name__ == "__main__":
	if os.path.exists("cleaner.db"):
		os.unlink("cleaner.db")
	db = RepositoryDatabase()
	session = db.session
	for build in builds:
		if not os.path.exists("%s/%s" % (initial_path, build)):
			continue
		snapdir = "%s/%s/snapshots" % ( initial_path, build )
		if os.path.isdir(snapdir) and not os.path.islink(snapdir):
			for match in glob.glob("%s/portage-*.tar.xz" % snapdir):
				basename = os.path.basename(match)
				if basename == "portage-current.tar.xz":
					continue
				sna = Snapshot()
				sna.path = match
				sna.build = build
				session.add(sna)
		for arch in arches:
			if not os.path.exists("%s/%s/%s" % ( initial_path, build, arch )):
				continue
			for subarch in subarches:
				path = "%s/%s/%s/%s" % (initial_path, build, arch, subarch)
				if not os.path.exists(path):
					continue
				most_recent = None
				most_recent_str = None
				for instance in os.listdir(path):
					try:
						date = datetime.datetime.strptime(instance,"%Y-%m-%d")
					except ValueError:
						continue
					ipath = "%s/%s" % ( path, instance )
					if not os.path.isdir(ipath):
						continue
					complete = False
					for match in glob.glob("%s/stage3*.tar.*" % ipath):
						complete = True
						break
					bdir = BuildDir()
					bdir.path = ipath
					bdir.date = date
					bdir.date_str = instance
					bdir.build = build
					bdir.arch = arch
					bdir.subarch = subarch
					bdir.complete = complete
					if complete:
						for match in glob.glob("%s/stage1*.tar.*" % ipath):
							bdir.full = True
							break
					session.add(bdir)
					if complete and ( most_recent == None or most_recent < bdir.date ):
						most_recent = bdir.date
						most_recent_str = bdir.date_str

				sa = SubArch()
				sa.build = build
				sa.arch = arch
				sa.subarch = subarch
				sa.date = most_recent
				sa.date_str = most_recent_str
				sa.path = path

				session.add(sa)

	session.commit()
now = datetime.datetime.now()
stale_days = 2
if len(sys.argv) > 1 and sys.argv[1] == "clean":
	for build in builds:
		for arch in arches:
			for subarch in subarches:
				out = session.query(BuildDir).filter_by(build=build).filter_by(arch=arch).filter_by(subarch=subarch).filter_by(complete=True).order_by(BuildDir.date_str).all()
				for x in out[0:-3]:
					print(("rm -rf %s" % x.path))
				for x in out[-3:]:
					print(("# keeping %s" % x.path))
		sna = session.query(Snapshot).filter_by(build=build).order_by(Snapshot.path).all()
		for x in sna[0:-2]:
			print(("rm %s" % x.path))
		for x in sna[-2:]:
			print(("# keeping %s" % x.path))
	for x in session.query(BuildDir).filter_by(complete=False):
		# ignore non-stale builds for cleaning -- they could be in-progress...
		if x.date != None and now - x.date < datetime.timedelta(days=stale_days):	
			print(("rm -rf %s # not complete" % x.path))
elif len(sys.argv) > 1 and sys.argv[1] == "nextbuild":
	sa = session.query(SubArch)
	for build in builds:
		# grab all subarches for this build...
		sa2 = sa.filter_by(build=build)
		# order subarches by date, oldest to newest, and iterate over them:
		for x in sa2.order_by(SubArch.__table__.c.date):
			# if something is newer than 4 days old, it is not considered stale, so we skip over it:
			if x.date != None and now - x.date < datetime.timedelta(days=stale_days):
				continue	
			# otherwise, we have found the next thing we should try to build. Output important info to stdout:
			if os.path.exists(x.path+"/.control/.multi_progress"):
				sys.stderr.write("Build at %s in progress, skipping...\n" % x.path)
				continue
			else:
				# output: build subarch was-last-build-full(had-a-stage-1)(boolean) date
				print(x.build, x.subarch, end=' ')
				b = session.query(BuildDir).filter_by(build=x.build).filter_by(subarch=x.subarch).filter_by(date_str=x.date_str).first()
				if b == None:
					print("None", end=' ')
				else:
					print(b.full, end=' ')
				print(map_build(x.build, x.subarch, b.full if b else None, x.date if b else None))
				sys.exit(0)
	sys.exit(1)
