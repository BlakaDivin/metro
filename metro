#!/usr/bin/python3 -OO

import os, sys, getopt, types, subprocess
from importlib import import_module

__app__ = os.path.basename(sys.argv[0])

# we need this hard-coded path because we need a module here before we can parse our config file
__maintainer__ = "Daniel Robbins <drobbins@funtoo.org>"

__license__ = """ Distributed under the terms of the GNU General Public License version 2
 Metro comes with ABSOLUTELY NO WARRANTY; This is free software, and you are welcome to
 redistribute it under certain conditions. See /usr/lib/metro/LICENSE for details.
"""
__status__ = "Release"
__version__ = "1.5.1"

def usage():
	version()
	print(""" metro [OPTION]... [FILE]...

 -h, --help					Print this message
 -V, --version				Display version information

 -d, --debug				Enable debug mode
 -f, --debug-flexdata		Resolve and print flexdata tree
 -v, --verbose				Verbose mode
 -l [dir], --libdir [dir]	Use alternate library dir (default /usr/lib/metro)

 -N, --notrigger			Disable build triggers

 -k [key], --key [key]		Print value of [key], ie. "distfiles"

 [FILE]						File(s) to parse and evaluate
	""")

def version():
	print(" " + __app__, "version", __version__)
	print()
	print(" Copyright 2008-2014 Funtoo Technologies, LLC")
	print(" Maintainer:", __maintainer__)
	print()
	print(" Web: http://www.funtoo.org")
	print(" Documentation: http://www.funtoo.org/wiki/Metro")
	print(" Project: https://github.com/funtoo/metro")
	print()
	print(__license__)

class Metro:
	def __init__(self):
		self.debug = False
		self.debug_flexdata = False
		self.verbose = False
		self.configfile = None
		self.optdict = {}
		self.flexdata = None
		self.targets = None
		self.ts = None
		self.multi_ts = None
		self.opts = None
		self.args = None

		# Step 0: parse out the command line arguments
		if len(sys.argv) < 2:
			usage()
			sys.exit(1)

		try:
			self.opts, self.args = getopt.getopt(sys.argv[1:], "dfhvxVk:l:", ["debug", "debug-flexdata", "help", "verbose", "version", "key=", "libdir="])
		except getopt.GetoptError:
			usage()
			sys.exit(1)

		self.optdict = dict(self.opts)

		self.debug = self.has_opts(["-d", "--debug"])
		self.debug_flexdata = self.has_opts(["-f", "--debug-flexdata"])
		self.verbose = self.has_opts(["-v", "--verbose"])

		# Step 1: check preconditions
		if os.getuid() != 0:
			raise RuntimeError("this script requires root privileges to operate")

		# Step 2: infer binpath and libdir and load modules
		self.setup_paths()

	def run(self):
		# Step 3: check for "special" help/version options, handle them and exit:
		if self.has_opts(["-h", "--help"]):
			usage()
			sys.exit(0)
		elif self.has_opts(["-V", "--version"]):
			version()
			sys.exit(0)

		# Step 5: Initialize Metro data
		settings = self.init_settings()

		if self.has_opts(["-k", "--key"]):
			print(settings[self.get_opts(["-k", "--key"])])
			sys.exit(0)

		# Step 6: Create list of targets to run, checking whether "multi" mode is enabled
		if settings["multi"] == "yes":
			targetlist = settings["multi/targets"].split()
		else:
			targetlist = [settings["target"]]

		self.run_targets(targetlist, self.args)

	def has_opts(self, opts, fnc=any):
		return fnc(key in self.optdict for key in opts)

	def get_opts(self, opts):
		result = None
		for key, value in list(self.optdict.items()):
			if key in opts:
				result = value
		return result

	def init_settings(self, extraargs=None):
		args = self.args
		settings = self.flexdata.collection(self.debug)

		# collect main configuration file
		if os.path.exists(self.configfile):
			settings.collect(self.configfile, None)
			settings["path/config"] = os.path.dirname(self.configfile)
		else:
			raise RuntimeError("config file '%s' not found" % self.configfile)

		# parse command-line supplied values
		# such as: target/version: 2008.10.12
		args = dict(list(zip(args[::2], args[1::2])))

		for key, value in list(args.items()):
			if key[-1] == ":":
				settings[key[:-1]] = value
			else:
				raise RuntimeError("cmdline argument '%s' invalid - does not end in a colon" % key)

		# add extra values
		if extraargs:
			for arg in list(extraargs.keys()):
				settings[arg] = extraargs[arg]
		settings.runCollector()
		if settings["portage/MAKEOPTS"] == "auto":
			settings["portage/MAKEOPTS"] = "-j%s" % (int(subprocess.getoutput("nproc")) + 1)

		return settings

	@staticmethod
	def dump_settings(settings):
		keys = list(settings.keys())
		keys.sort()
		for key in keys:
			try:
				value = settings[key]
			except:
				print(key+" cannot be resolved with this target!")
			else:
				if type(value) is list:
					print(key+": [...]")
				else:
					print(key+": "+str(settings[key]))

	def setup_paths(self):
		binpath = os.path.realpath(sys.argv[0])

		libdir = os.path.dirname(binpath)
		if self.has_opts(["-l", "--libdir"]):
			libdir = self.get_opts(["-l", "--libdir"])

		if self.verbose:
			print("Using library directory of %s.\n" % libdir)
		sys.path.append(libdir+"/modules")

		self.configfile = os.path.expanduser("~/.metro")
		if not os.path.exists(self.configfile):
			print("Please copy %s to ~/.metro and customize for your environment." % (libdir+"/metro.conf"))
			sys.exit(1)
		if self.verbose:
			print("Using main configuration file %s.\n" % self.configfile)

		self.flexdata = import_module("flexdata")
		self.targets = import_module("targets")

	def run_targets(self, targetlist, args):

		temp_targets = targetlist[:]
		try:
			temp_targets.remove("snapshot")
		except ValueError:
			pass


		if len(temp_targets):

			# We are doing a multi-target build:

			# It looks like we are building something. Therefore, we should "lock" the build/arch/subarch.
			# This locking will allow other multi-target runs to abort early, and allow buildbot to actually
			# skip over in-progress multi-targets so it can build the next multi-target (allowing parallel
			# multi-target builds.

			initial_settings = self.init_settings()
			multi_tsfn = initial_settings["path/mirror/target/control"] + "/.multi_progress"
			self.multi_ts = timestampFile(multi_tsfn)
			if self.multi_ts.exists():
				print("Multi-target already in progress -- %s exists. Aborting." % self.multi_ts.path)
				sys.exit(1)
			else:
				if not self.multi_ts.create():
					print("Could not create multi-target timestamp file %s" % self.multi_ts.path)
					sys.exit(1)
		
		for targetname in targetlist:
			settings = self.init_settings({"target": targetname})
			target = self.find_target(settings)

			print("Running target %s with class %s" % (targetname, settings["target/class"]))
			
			#Initial setup to test if target exists, and if so, create an "in progress" timeStampFile:
					
			if targetname == "snapshot":
				tsfn = targ = settings["path/mirror/snapshot"]
				tsfn = os.path.join(os.path.dirname(tsfn), "." + os.path.basename(tsfn) + "_progress")
			else:
				tsfn = os.path.join(settings["path/mirror/target/control"], "." + targetname + "_progress")
				targ = settings["path/mirror/target"]

			#Let's see if our target exists. Should we replace it? Or should we just skip it?

			if "metro/options" in settings and "replace" in settings["metro/options"].split():
				if os.path.exists(targ):
					print("Removing existing file %s..." % targ)
					target.cmd(self.cmds["rm"] + " -f " + targ)
			elif os.path.exists(targ):
				print("File %s already exists - skipping..." % targ)
				target.run_script("trigger/ok/run", optional=True)
				continue

			# Okay, we need to build our target. Let's create an "in progress" timestamp file:

			# dump all settings
			if self.debug_flexdata:
				Metro.dump_settings(settings)
			self.ts = timestampFile(tsfn)
			abort = False
			error = False
			if self.ts.exists():
				print("Target already in progress -- %s exists. Aborting." % self.ts.path)
				abort = True
			else:
				if not self.ts.create():
					print("Could not create timestamp file %s" % self.ts.path)
					abort = error = True
			try:
				if not abort:
					target.run()
					
					print("Target run complete")
					print()
			except KeyboardInterrupt:
				print("Target %s aborted due to user interrupt (ctrl-C)" % target)
				abort = error = True
				if self.ts != None:
					self.ts.unlink()
				# break out of multi-target loop so we can exit:
				break
		if self.multi_ts != None:
			self.multi_ts.unlink()
		if abort:
			sys.exit(1 if error else 0)

	def find_target(self, settings):
		"""

		Use the "target/class" setting in our metadata to initialize the proper class defined in the modules/targets.py module.

		The targets.__dict__ dictionary contains all the objects in the targets module. We look inside it to see if the class
		defined in "target/class" exists in there and is a class. If not, we raise an exception.

		"""
		cls = settings["target/class"].capitalize()+"Target"
		if cls not in self.targets.__dict__:
			raise NameError("target class "+cls+" not defined in modules/targets.py.")
		if type(self.targets.__dict__[cls]) != type:
			raise NameError("target class "+cls+" does not appear to be a class.")
		return self.targets.__dict__[cls](settings)


m = Metro()
from metro_support import timestampFile
m.run()
